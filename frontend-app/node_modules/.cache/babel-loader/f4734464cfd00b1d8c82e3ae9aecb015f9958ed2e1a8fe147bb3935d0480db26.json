{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport { useWallet } from '../context/WalletContext';\nimport { SIMPLE_SWAP_ABI, ERC20_ABI } from '../config/web3';\nexport const useSimpleSwap = () => {\n  _s();\n  const {\n    isConnected,\n    address,\n    signer,\n    contracts\n  } = useWallet();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Estados para los datos de los tokens\n  const [tokenAAddress, setTokenAAddress] = useState(null);\n  const [tokenBAddress, setTokenBAddress] = useState(null);\n  const [tokenASymbol, setTokenASymbol] = useState('TKNA');\n  const [tokenBSymbol, setTokenBSymbol] = useState('TKNB');\n  const [tokenABalance, setTokenABalance] = useState('0');\n  const [tokenBBalance, setTokenBBalance] = useState('0');\n  const [tokenAAllowance, setTokenAAllowance] = useState('0');\n  const [tokenBAllowance, setTokenBAllowance] = useState('0');\n  const [reserves, setReserves] = useState(null);\n\n  // Función para crear instancias de contratos\n  const getContracts = () => {\n    if (!signer || !contracts) return null;\n\n    // Verificar que las direcciones no estén vacías\n    if (!contracts.SimpleSwap || !contracts.TokenA || !contracts.TokenB) {\n      console.error('Direcciones de contratos no configuradas para esta red');\n      return null;\n    }\n    return {\n      simpleSwap: new ethers.Contract(contracts.SimpleSwap, SIMPLE_SWAP_ABI, signer),\n      tokenA: new ethers.Contract(contracts.TokenA, ERC20_ABI, signer),\n      tokenB: new ethers.Contract(contracts.TokenB, ERC20_ABI, signer)\n    };\n  };\n\n  // Cargar datos iniciales cuando se conecta\n  useEffect(() => {\n    const loadData = async () => {\n      if (!isConnected || !signer || !contracts) return;\n      try {\n        const contractInstances = getContracts();\n        if (!contractInstances) return;\n        const {\n          simpleSwap,\n          tokenA,\n          tokenB\n        } = contractInstances;\n\n        // Cargar direcciones de tokens\n        const [tokenAAddr, tokenBAddr] = await Promise.all([simpleSwap.tokenA(), simpleSwap.tokenB()]);\n        setTokenAAddress(tokenAAddr);\n        setTokenBAddress(tokenBAddr);\n\n        // Cargar símbolos\n        const [symbolA, symbolB] = await Promise.all([tokenA.symbol(), tokenB.symbol()]);\n        setTokenASymbol(symbolA);\n        setTokenBSymbol(symbolB);\n\n        // Cargar balances iniciales\n        await loadBalances();\n        await loadReserves();\n        await loadAllowances();\n      } catch (err) {\n        console.error('Error cargando datos:', err);\n        setError(err.message);\n      }\n    };\n    loadData();\n  }, [isConnected, signer, contracts, address]);\n\n  // Cargar balances de tokens\n  const loadBalances = async () => {\n    if (!isConnected || !address || !contracts) return;\n    try {\n      const contractInstances = getContracts();\n      if (!contractInstances) return;\n      const {\n        tokenA,\n        tokenB\n      } = contractInstances;\n      const [balanceA, balanceB] = await Promise.all([tokenA.balanceOf(address), tokenB.balanceOf(address)]);\n      setTokenABalance(ethers.formatEther(balanceA));\n      setTokenBBalance(ethers.formatEther(balanceB));\n    } catch (err) {\n      console.error('Error cargando balances:', err);\n    }\n  };\n\n  // Cargar reservas del pool\n  const loadReserves = async () => {\n    if (!contracts) return;\n    try {\n      const contractInstances = getContracts();\n      if (!contractInstances) return;\n      const {\n        simpleSwap\n      } = contractInstances;\n      const reservesData = await simpleSwap.getReserves();\n      setReserves({\n        reserveA: ethers.formatEther(reservesData[0]),\n        reserveB: ethers.formatEther(reservesData[1])\n      });\n    } catch (err) {\n      console.error('Error cargando reservas:', err);\n    }\n  };\n\n  // Cargar allowances\n  const loadAllowances = async () => {\n    if (!isConnected || !address || !contracts) return;\n    try {\n      const contractInstances = getContracts();\n      if (!contractInstances) return;\n      const {\n        tokenA,\n        tokenB\n      } = contractInstances;\n      const [allowanceA, allowanceB] = await Promise.all([tokenA.allowance(address, contracts.SimpleSwap), tokenB.allowance(address, contracts.SimpleSwap)]);\n      setTokenAAllowance(allowanceA.toString());\n      setTokenBAllowance(allowanceB.toString());\n    } catch (err) {\n      console.error('Error cargando allowances:', err);\n    }\n  };\n\n  // Obtener cantidad de salida para el swap\n  const getAmountOut = async (tokenIn, tokenOut, amountIn) => {\n    try {\n      if (!amountIn || amountIn === '0' || !contracts) return '0';\n      const contractInstances = getContracts();\n      if (!contractInstances) return '0';\n      const {\n        simpleSwap\n      } = contractInstances;\n      const amountOut = await simpleSwap.getAmountOut(tokenIn, tokenOut, ethers.parseEther(amountIn));\n      return ethers.formatEther(amountOut);\n    } catch (error) {\n      console.error('Error obteniendo cantidad de salida:', error);\n      return '0';\n    }\n  };\n\n  // Obtener precio\n  const getPrice = async (tokenA, tokenB) => {\n    try {\n      if (!contracts) return '0';\n      const contractInstances = getContracts();\n      if (!contractInstances) return '0';\n      const {\n        simpleSwap\n      } = contractInstances;\n      const price = await simpleSwap.getPrice(tokenA, tokenB);\n      return ethers.formatEther(price);\n    } catch (error) {\n      console.error('Error obteniendo precio:', error);\n      return '0';\n    }\n  };\n\n  // Aprobar gasto de tokens\n  const approveToken = async (tokenAddress, amount) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const contractInstances = getContracts();\n      if (!contractInstances) throw new Error('Contratos no disponibles');\n      const isTokenA = tokenAddress === contracts.TokenA;\n      const tokenContract = isTokenA ? contractInstances.tokenA : contractInstances.tokenB;\n      const tx = await tokenContract.approve(contracts.SimpleSwap, ethers.parseEther(amount));\n      await tx.wait();\n\n      // Recargar allowances después de la aprobación\n      await loadAllowances();\n      return true;\n    } catch (error) {\n      setError(error.message);\n      console.error('Error aprobando token:', error);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Intercambiar tokens\n  const swapTokens = async (amountIn, amountOutMin, path) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const contractInstances = getContracts();\n      if (!contractInstances) throw new Error('Contratos no disponibles');\n      const {\n        simpleSwap\n      } = contractInstances;\n      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hora\n\n      const tx = await simpleSwap.swapExactTokensForTokens(ethers.parseEther(amountIn), ethers.parseEther(amountOutMin), path, address, deadline);\n      await tx.wait();\n\n      // Recargar datos después del swap\n      await loadBalances();\n      await loadReserves();\n      return true;\n    } catch (error) {\n      setError(error.message);\n      console.error('Error intercambiando tokens:', error);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Agregar liquidez\n  const addLiquidity = async (amountA, amountB, amountAMin, amountBMin) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const contractInstances = getContracts();\n      if (!contractInstances) throw new Error('Contratos no disponibles');\n      const {\n        simpleSwap\n      } = contractInstances;\n      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hora\n\n      const tx = await simpleSwap.addLiquidity(contracts.TokenA, contracts.TokenB, ethers.parseEther(amountA), ethers.parseEther(amountB), ethers.parseEther(amountAMin), ethers.parseEther(amountBMin), address, deadline);\n      await tx.wait();\n\n      // Recargar datos después de agregar liquidez\n      await loadBalances();\n      await loadReserves();\n      return true;\n    } catch (error) {\n      setError(error.message);\n      console.error('Error agregando liquidez:', error);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Remover liquidez\n  const removeLiquidity = async (liquidity, amountAMin, amountBMin) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const contractInstances = getContracts();\n      if (!contractInstances) throw new Error('Contratos no disponibles');\n      const {\n        simpleSwap\n      } = contractInstances;\n      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hora\n\n      const tx = await simpleSwap.removeLiquidity(contracts.TokenA, contracts.TokenB, ethers.parseEther(liquidity), ethers.parseEther(amountAMin), ethers.parseEther(amountBMin), address, deadline);\n      await tx.wait();\n\n      // Recargar datos después de remover liquidez\n      await loadBalances();\n      await loadReserves();\n      return true;\n    } catch (error) {\n      setError(error.message);\n      console.error('Error removiendo liquidez:', error);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Mintear tokens de prueba\n  const mintTokens = async (tokenAddress, amount) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const contractInstances = getContracts();\n      if (!contractInstances) throw new Error('Contratos no disponibles');\n      const isTokenA = tokenAddress === contracts.TokenA;\n      const tokenContract = isTokenA ? contractInstances.tokenA : contractInstances.tokenB;\n      const tx = await tokenContract.mint(address, ethers.parseEther(amount));\n      await tx.wait();\n\n      // Recargar balances después del mint\n      await loadBalances();\n      return true;\n    } catch (error) {\n      setError(error.message);\n      console.error('Error minteando tokens:', error);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Verificar si necesita aprobación\n  const needsApproval = (tokenAddress, amount) => {\n    if (!amount || amount === '0') return false;\n    const allowance = tokenAddress === (contracts === null || contracts === void 0 ? void 0 : contracts.TokenA) ? tokenAAllowance : tokenBAllowance;\n    console.log('needsApproval debug:', {\n      tokenAddress,\n      amount,\n      allowance,\n      contractTokenA: contracts === null || contracts === void 0 ? void 0 : contracts.TokenA,\n      parsedAmount: ethers.parseEther(amount).toString()\n    });\n    if (!allowance || allowance === '0') return true;\n    return ethers.parseEther(amount) > ethers.getBigInt(allowance);\n  };\n\n  // Función utilitaria para formatear balance\n  const formatBalance = balance => {\n    return balance || '0';\n  };\n  return {\n    // Direcciones de contratos\n    contracts,\n    // Estado de conexión\n    isConnected,\n    address,\n    // Estados de carga\n    isLoading,\n    error,\n    // Datos de tokens\n    tokenAAddress,\n    tokenBAddress,\n    tokenASymbol,\n    tokenBSymbol,\n    tokenABalance,\n    tokenBBalance,\n    tokenAAllowance,\n    tokenBAllowance,\n    // Datos del pool\n    reserves,\n    // Funciones\n    getAmountOut,\n    getPrice,\n    approveToken,\n    swapTokens,\n    addLiquidity,\n    removeLiquidity,\n    mintTokens,\n    needsApproval,\n    loadBalances,\n    loadReserves,\n    // Utilidades\n    formatBalance\n  };\n};\n_s(useSimpleSwap, \"2r90mSTQfljT/8ic0SdZ2VlVD0c=\", false, function () {\n  return [useWallet];\n});","map":{"version":3,"names":["useState","useEffect","ethers","useWallet","SIMPLE_SWAP_ABI","ERC20_ABI","useSimpleSwap","_s","isConnected","address","signer","contracts","isLoading","setIsLoading","error","setError","tokenAAddress","setTokenAAddress","tokenBAddress","setTokenBAddress","tokenASymbol","setTokenASymbol","tokenBSymbol","setTokenBSymbol","tokenABalance","setTokenABalance","tokenBBalance","setTokenBBalance","tokenAAllowance","setTokenAAllowance","tokenBAllowance","setTokenBAllowance","reserves","setReserves","getContracts","SimpleSwap","TokenA","TokenB","console","simpleSwap","Contract","tokenA","tokenB","loadData","contractInstances","tokenAAddr","tokenBAddr","Promise","all","symbolA","symbolB","symbol","loadBalances","loadReserves","loadAllowances","err","message","balanceA","balanceB","balanceOf","formatEther","reservesData","getReserves","reserveA","reserveB","allowanceA","allowanceB","allowance","toString","getAmountOut","tokenIn","tokenOut","amountIn","amountOut","parseEther","getPrice","price","approveToken","tokenAddress","amount","Error","isTokenA","tokenContract","tx","approve","wait","swapTokens","amountOutMin","path","deadline","Math","floor","Date","now","swapExactTokensForTokens","addLiquidity","amountA","amountB","amountAMin","amountBMin","removeLiquidity","liquidity","mintTokens","mint","needsApproval","log","contractTokenA","parsedAmount","getBigInt","formatBalance","balance"],"sources":["C:/Users/Admin/Downloads/Curso-Solidity/frontend-app/src/hooks/useSimpleSwap.js"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { ethers } from 'ethers';\r\nimport { useWallet } from '../context/WalletContext';\r\nimport { SIMPLE_SWAP_ABI, ERC20_ABI } from '../config/web3';\r\n\r\nexport const useSimpleSwap = () => {\r\n  const { isConnected, address, signer, contracts } = useWallet();\r\n  \r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  \r\n  // Estados para los datos de los tokens\r\n  const [tokenAAddress, setTokenAAddress] = useState(null);\r\n  const [tokenBAddress, setTokenBAddress] = useState(null);\r\n  const [tokenASymbol, setTokenASymbol] = useState('TKNA');\r\n  const [tokenBSymbol, setTokenBSymbol] = useState('TKNB');\r\n  const [tokenABalance, setTokenABalance] = useState('0');\r\n  const [tokenBBalance, setTokenBBalance] = useState('0');\r\n  const [tokenAAllowance, setTokenAAllowance] = useState('0');\r\n  const [tokenBAllowance, setTokenBAllowance] = useState('0');\r\n  const [reserves, setReserves] = useState(null);\r\n\r\n  // Función para crear instancias de contratos\r\n  const getContracts = () => {\r\n    if (!signer || !contracts) return null;\r\n    \r\n    // Verificar que las direcciones no estén vacías\r\n    if (!contracts.SimpleSwap || !contracts.TokenA || !contracts.TokenB) {\r\n      console.error('Direcciones de contratos no configuradas para esta red');\r\n      return null;\r\n    }\r\n    \r\n    return {\r\n      simpleSwap: new ethers.Contract(contracts.SimpleSwap, SIMPLE_SWAP_ABI, signer),\r\n      tokenA: new ethers.Contract(contracts.TokenA, ERC20_ABI, signer),\r\n      tokenB: new ethers.Contract(contracts.TokenB, ERC20_ABI, signer)\r\n    };\r\n  };\r\n\r\n  // Cargar datos iniciales cuando se conecta\r\n  useEffect(() => {\r\n    const loadData = async () => {\r\n      if (!isConnected || !signer || !contracts) return;\r\n\r\n      try {\r\n        const contractInstances = getContracts();\r\n        if (!contractInstances) return;\r\n\r\n        const { simpleSwap, tokenA, tokenB } = contractInstances;\r\n\r\n        // Cargar direcciones de tokens\r\n        const [tokenAAddr, tokenBAddr] = await Promise.all([\r\n          simpleSwap.tokenA(),\r\n          simpleSwap.tokenB()\r\n        ]);\r\n        \r\n        setTokenAAddress(tokenAAddr);\r\n        setTokenBAddress(tokenBAddr);\r\n\r\n        // Cargar símbolos\r\n        const [symbolA, symbolB] = await Promise.all([\r\n          tokenA.symbol(),\r\n          tokenB.symbol()\r\n        ]);\r\n        \r\n        setTokenASymbol(symbolA);\r\n        setTokenBSymbol(symbolB);\r\n\r\n        // Cargar balances iniciales\r\n        await loadBalances();\r\n        await loadReserves();\r\n        await loadAllowances();\r\n\r\n      } catch (err) {\r\n        console.error('Error cargando datos:', err);\r\n        setError(err.message);\r\n      }\r\n    };\r\n\r\n    loadData();\r\n  }, [isConnected, signer, contracts, address]);\r\n\r\n  // Cargar balances de tokens\r\n  const loadBalances = async () => {\r\n    if (!isConnected || !address || !contracts) return;\r\n\r\n    try {\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) return;\r\n\r\n      const { tokenA, tokenB } = contractInstances;\r\n\r\n      const [balanceA, balanceB] = await Promise.all([\r\n        tokenA.balanceOf(address),\r\n        tokenB.balanceOf(address)\r\n      ]);\r\n\r\n      setTokenABalance(ethers.formatEther(balanceA));\r\n      setTokenBBalance(ethers.formatEther(balanceB));\r\n    } catch (err) {\r\n      console.error('Error cargando balances:', err);\r\n    }\r\n  };\r\n\r\n  // Cargar reservas del pool\r\n  const loadReserves = async () => {\r\n    if (!contracts) return;\r\n\r\n    try {\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) return;\r\n\r\n      const { simpleSwap } = contractInstances;\r\n      const reservesData = await simpleSwap.getReserves();\r\n      \r\n      setReserves({\r\n        reserveA: ethers.formatEther(reservesData[0]),\r\n        reserveB: ethers.formatEther(reservesData[1])\r\n      });\r\n    } catch (err) {\r\n      console.error('Error cargando reservas:', err);\r\n    }\r\n  };\r\n\r\n  // Cargar allowances\r\n  const loadAllowances = async () => {\r\n    if (!isConnected || !address || !contracts) return;\r\n\r\n    try {\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) return;\r\n\r\n      const { tokenA, tokenB } = contractInstances;\r\n\r\n      const [allowanceA, allowanceB] = await Promise.all([\r\n        tokenA.allowance(address, contracts.SimpleSwap),\r\n        tokenB.allowance(address, contracts.SimpleSwap)\r\n      ]);\r\n\r\n      setTokenAAllowance(allowanceA.toString());\r\n      setTokenBAllowance(allowanceB.toString());\r\n    } catch (err) {\r\n      console.error('Error cargando allowances:', err);\r\n    }\r\n  };\r\n\r\n  // Obtener cantidad de salida para el swap\r\n  const getAmountOut = async (tokenIn, tokenOut, amountIn) => {\r\n    try {\r\n      if (!amountIn || amountIn === '0' || !contracts) return '0';\r\n      \r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) return '0';\r\n\r\n      const { simpleSwap } = contractInstances;\r\n      const amountOut = await simpleSwap.getAmountOut(\r\n        tokenIn, \r\n        tokenOut, \r\n        ethers.parseEther(amountIn)\r\n      );\r\n\r\n      return ethers.formatEther(amountOut);\r\n    } catch (error) {\r\n      console.error('Error obteniendo cantidad de salida:', error);\r\n      return '0';\r\n    }\r\n  };\r\n\r\n  // Obtener precio\r\n  const getPrice = async (tokenA, tokenB) => {\r\n    try {\r\n      if (!contracts) return '0';\r\n      \r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) return '0';\r\n\r\n      const { simpleSwap } = contractInstances;\r\n      const price = await simpleSwap.getPrice(tokenA, tokenB);\r\n\r\n      return ethers.formatEther(price);\r\n    } catch (error) {\r\n      console.error('Error obteniendo precio:', error);\r\n      return '0';\r\n    }\r\n  };\r\n\r\n  // Aprobar gasto de tokens\r\n  const approveToken = async (tokenAddress, amount) => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) throw new Error('Contratos no disponibles');\r\n\r\n      const isTokenA = tokenAddress === contracts.TokenA;\r\n      const tokenContract = isTokenA ? contractInstances.tokenA : contractInstances.tokenB;\r\n\r\n      const tx = await tokenContract.approve(\r\n        contracts.SimpleSwap, \r\n        ethers.parseEther(amount)\r\n      );\r\n      \r\n      await tx.wait();\r\n      \r\n      // Recargar allowances después de la aprobación\r\n      await loadAllowances();\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      setError(error.message);\r\n      console.error('Error aprobando token:', error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Intercambiar tokens\r\n  const swapTokens = async (amountIn, amountOutMin, path) => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) throw new Error('Contratos no disponibles');\r\n\r\n      const { simpleSwap } = contractInstances;\r\n      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hora\r\n\r\n      const tx = await simpleSwap.swapExactTokensForTokens(\r\n        ethers.parseEther(amountIn),\r\n        ethers.parseEther(amountOutMin),\r\n        path,\r\n        address,\r\n        deadline\r\n      );\r\n\r\n      await tx.wait();\r\n      \r\n      // Recargar datos después del swap\r\n      await loadBalances();\r\n      await loadReserves();\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      setError(error.message);\r\n      console.error('Error intercambiando tokens:', error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Agregar liquidez\r\n  const addLiquidity = async (amountA, amountB, amountAMin, amountBMin) => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) throw new Error('Contratos no disponibles');\r\n\r\n      const { simpleSwap } = contractInstances;\r\n      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hora\r\n\r\n      const tx = await simpleSwap.addLiquidity(\r\n        contracts.TokenA,\r\n        contracts.TokenB,\r\n        ethers.parseEther(amountA),\r\n        ethers.parseEther(amountB),\r\n        ethers.parseEther(amountAMin),\r\n        ethers.parseEther(amountBMin),\r\n        address,\r\n        deadline\r\n      );\r\n\r\n      await tx.wait();\r\n      \r\n      // Recargar datos después de agregar liquidez\r\n      await loadBalances();\r\n      await loadReserves();\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      setError(error.message);\r\n      console.error('Error agregando liquidez:', error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Remover liquidez\r\n  const removeLiquidity = async (liquidity, amountAMin, amountBMin) => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) throw new Error('Contratos no disponibles');\r\n\r\n      const { simpleSwap } = contractInstances;\r\n      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hora\r\n\r\n      const tx = await simpleSwap.removeLiquidity(\r\n        contracts.TokenA,\r\n        contracts.TokenB,\r\n        ethers.parseEther(liquidity),\r\n        ethers.parseEther(amountAMin),\r\n        ethers.parseEther(amountBMin),\r\n        address,\r\n        deadline\r\n      );\r\n\r\n      await tx.wait();\r\n      \r\n      // Recargar datos después de remover liquidez\r\n      await loadBalances();\r\n      await loadReserves();\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      setError(error.message);\r\n      console.error('Error removiendo liquidez:', error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Mintear tokens de prueba\r\n  const mintTokens = async (tokenAddress, amount) => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const contractInstances = getContracts();\r\n      if (!contractInstances) throw new Error('Contratos no disponibles');\r\n\r\n      const isTokenA = tokenAddress === contracts.TokenA;\r\n      const tokenContract = isTokenA ? contractInstances.tokenA : contractInstances.tokenB;\r\n\r\n      const tx = await tokenContract.mint(address, ethers.parseEther(amount));\r\n      await tx.wait();\r\n      \r\n      // Recargar balances después del mint\r\n      await loadBalances();\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      setError(error.message);\r\n      console.error('Error minteando tokens:', error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Verificar si necesita aprobación\r\n  const needsApproval = (tokenAddress, amount) => {\r\n    if (!amount || amount === '0') return false;\r\n    \r\n    const allowance = tokenAddress === contracts?.TokenA ? tokenAAllowance : tokenBAllowance;\r\n    console.log('needsApproval debug:', {\r\n      tokenAddress,\r\n      amount,\r\n      allowance,\r\n      contractTokenA: contracts?.TokenA,\r\n      parsedAmount: ethers.parseEther(amount).toString()\r\n    });\r\n    \r\n    if (!allowance || allowance === '0') return true;\r\n    \r\n    return ethers.parseEther(amount) > ethers.getBigInt(allowance);\r\n  };\r\n\r\n  // Función utilitaria para formatear balance\r\n  const formatBalance = (balance) => {\r\n    return balance || '0';\r\n  };\r\n\r\n  return {\r\n    // Direcciones de contratos\r\n    contracts,\r\n    \r\n    // Estado de conexión\r\n    isConnected,\r\n    address,\r\n    \r\n    // Estados de carga\r\n    isLoading,\r\n    error,\r\n    \r\n    // Datos de tokens\r\n    tokenAAddress,\r\n    tokenBAddress,\r\n    tokenASymbol,\r\n    tokenBSymbol,\r\n    tokenABalance,\r\n    tokenBBalance,\r\n    tokenAAllowance,\r\n    tokenBAllowance,\r\n    \r\n    // Datos del pool\r\n    reserves,\r\n    \r\n    // Funciones\r\n    getAmountOut,\r\n    getPrice,\r\n    approveToken,\r\n    swapTokens,\r\n    addLiquidity,\r\n    removeLiquidity,\r\n    mintTokens,\r\n    needsApproval,\r\n    loadBalances,\r\n    loadReserves,\r\n    \r\n    // Utilidades\r\n    formatBalance\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}